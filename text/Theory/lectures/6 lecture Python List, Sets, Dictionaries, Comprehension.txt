----------Set(множества)----------------
----------Конкатенация
----------Объеденение выполняется через команду union() или через |
a = {1, 2, 3, 4, 5}
b = {3, 4, 5, 6, 7, 8}
print(a.union(b))

Output: {1, 2, 3, 4, 5, 6, 7, 8}

Set структура не упорядоченая. Цифры до 256 сохраняют порядок, но строки могут принимать различный порядок.
В set мы можем добавлять элементы с помощью команды add()


-------------Intersection (пересечение) выполняется операцие intersection() или &

Input: a = {1, 2, 3, 4, 5}
       b = {3, 4, 5, 6, 7, 8}
       print(a & b)

Output: {3, 4, 5}
Если пересечений нет, то выведет просто {}

-----------Difference (разница) выводит символы, которых нет в одном множестве по отношению к другому.
Мы можем использованный данный метод для поиска уникальных элементов и последующей передачи их в другую структуру.
Метод реализуется командой difference() или - .
Input:
a = {1, 2, 3, 4, 5}
b = {3, 4, 5, 6, 7, 8}
print(a - b)

Output: {1, 2}

Input: 
a = {1, 2, 3, 4, 5}
b = {3, 4, 5, 6, 7, 8}
print(b - a)

Output: {8, 6, 7}

------------Symetric Difference (симетричная разница) возвращает значения двух(или более) множеств, которые не
в них не повторяются(удаляем общие элементы).
Реализуется командой symetric difference() или ^.

Input:
a = {1, 2, 3, 4, 5}
b = {3, 4, 5, 6, 7, 8}
c = {7, 8, 9, 10, 11, 12}
print(a ^ b ^ c)

Output: {1, 2, 6, 9, 10, 11, 12}

-----------isDisjoint = True если нет общих элементов

-----------isSubset = True если s1 является сабсетом s2  Можно определять знаками <= и >= по типу:
 Суперсет >= сабсет.

-----------isSuperset = True - если s1 является суперменом для s2(обратное isSubset только s2 является суперменом 
s1 в примере выше).

Input :
a = {1, 2, 3}
b = {4, 5, 6}
c = {1, 2, 3, 4, 5, 6}
print(a.isdisjoint(b))
print(a.issubset(c))
print(b.issubset(c))
print(b.issuperset(c))
print(c.issuperset(b))

Output:
True - так как у а и b нет обших элементов
True - а входит в с 
True - b входис с 
False - б не является суперсетом, куда входит с 
True - с является суперсетом куда входит б


------------------List Slicing(срезы списков)----------------------------
С помощью срезов мы можем выводить саблисты списков.
list = [1, 2, 3, 4, 5, 6, 7]
list = list[:-1] - удаляет новый элемент

-----------------------Dictionaries--------------------
Хождение по values and keys

--Итерация по ключам(так как я не указываю, по чём итерируюсь). Можно указать явным образом friendsAndCash.keys()
friendsAndCash = {'John': '20$', 'Dan': '35$', 'Lois': '14$', 'Doug': '144$'} 
for i in friendsAndCash:  
    print(i)              

--Итерация только по значениям
friendsAndCash = {'John': '20$', 'Dan': '35$', 'Lois': '14$', 'Doug': '144$'}
for i in friendsAndCash.values():
    print(i)

-- Итерация и по ключам и по значениям
friendsAndCash = {'John': '20$', 'Dan': '35$', 'Lois': '14$', 'Doug': '144$'}
for (k, i) in friendsAndCash.items():
    print(k, i)

Тут мы можем выводить то, что нам необходимо


------------------------Comprehension--------------------
Конструкции, которые позволяют строить последовательности из других последовательностей.
Input:
list = [1, 'c', 2, 'v', 3, 'r', 4, 9]
squared_ints = [i**2 for i in list if type(i) == int]
print(squared_ints)

Output: [1, 4, 9, 16, 81]

Выводит числа int в квадрате.

---- Генерация списка значений
list = [i for i in range(1, 11)]
print(list)
Таким образом я могу создать список необходимых мне значений.

strng = 'fsdsd212ffsdl 432fk2 kggk9'
print([int(i) for i in strng if '0' <= i <= '9'])
Таким способом мы можем сразу же добавлять в массив целые числа из строки.

------
names = ['diMA', 'ANdrEY', 'george', 'aRTem', 'V']
print({name[0].upper() + name[1:].lower() for name in names if len(name) > 1})
Таким способом мы можем делать первую букву в строчке большой, а остальные маленькие

-----
dict_a = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
dict_b = {k: v*2 for k, v in dict_a.items()}
print(dict_b)

Изменяем значение ключей в словаре

Использование Comprehension списка вместо цикла означает, что вы:
1. не строите список - оригинальную последовательно я не модифицирую
2. не накапливаете бессмысленные значения при построении списка - не занимаю память.
3. не занимаетесь расширением списка

НО! Comprehension списков - это не волшебство, которое по своей сути быстрее старого доброго цикла.
 То есть использовать, когда необходимо сделать простые операции(без else)


















Вопросы:
1. Как в set упордоячить выведение строк?