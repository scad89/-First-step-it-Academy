В ООП мы можем оперировать с:
Обьект > Класс > Наследование > Полиморфизм > Абстракция > Инкапсуляция.

Наследование- возможность унаследовать свойства и функции в дочернем классе. 
К примеру если два класса. Дочерний и родительский. Дочерний наследует всей свой и методы родительского класса и, возможно,
добавил какие-то свои.
При наследовании мы можем создать новый конструктор ___init___, если к нему добавятся новые значения



Полиморфизм - любой объект в пайтоне является полиморфным, так как его можно сделать таковым. Одно написание
функции, но разная реализация. Пример ручка, карандаш, стилус. Они все выполняют функционал "писать", но параметры
разные.
В других языках, при вызове метода используется конкректная типизация и идёт обращение к кокректному объекту. В пайтоне
любой объект полиморфен.


Инкапсуляция - это возможность сокрытия каких-либо данных от публичного доступа.
Для того, чтобы сделать перменную(функцию) приватной, необходимо перед ней поставить нижнее подчёркивание.


Пример:
def _calculation(a, b):
    return a * b

Это показывает, что данная функция является приватной и её лучше не трогать.


Пример создания класса:
class Jedi:
    def __init__(self, name, ammo):    # таким образом я могу начать описывать мой объект
        self.name = name
        self.ammo = ammo

    def _power(self):    # инкапсуляция
        print(self.ammo * 3)

    def shot(self):    # у функции внутри класса будет обязательный параметр self
        print(self.ammo)


if __name__ == '__main__':    # с помощью этого всё запускается в main.
    jediObiWan = Jedi('Obi Wan', 'blaster')
    jediObiWan.shot()
    yoda = Jedi('Yoda', 'Laser Sword')
    yoda.shot()

    jediObiWan._power() # эту строку тут записывать не правильно. 


if __name__ == '__main__': можно пренебречь, но по правилам необходимо писать эту строку.

jedi всего лишь переменная, в которую мы вставляем то, что нам вернёт класс. То есть осмысленная перменная.

self - это внутреннее значение нашего класса.
То есть, чтобы обратиться к полям класса, я должен буду обратиться к ним через self. self нужен для внутренних взаимодействий
внутри класса.

__init__ по другому называется конструктор. Сдесь мы описываем значения, которые нам пришли в качестве параметров
в данный класс в объект. Дальше мы можем с этим объектом взаимодействовать.


Пример наследования, полиморфизма и инкапсуляции:

class DrawObject:
    def __init__(self, name):    # таким образом я могу начать описывать мой объект
        self.name = name

    def draw(self):    # у функции внутри класса будет обязательный параметр self
        print(self.name)


class Pencil(DrawObject):
    def __init__(self, name, size):
        self.name = name
        self.size = size

    def _ChangeSize(self, count):    # метод инкапсулирования
        self.size -= count

    def sharpen(self):
        self._ChangeSize(10)    # инкапсуляция
        print('Наточим карандаш')

    def draw(self):    # переопределение метода draw без наследования её из родителя
        self._ChangeSize(1)    # инкапсуляция
        print('Мы пишем грифелем')


class Pen(DrawObject):
    def change(self):
        print('Смена стержня')

    def draw(self):    # переопределение метода draw без наследования её из родителя
        print('Мы пишем гелем')


class Stylus(DrawObject):
    def charge(self):
        print('Зарядка')

    def draw(self):    # переопределение метода draw без наследования её из родителя
        print('Мы в планшете')


if __name__ == '__main__':
    pen = Pen('Pen')    # тут не требуется обязательно писать тип объекта(полиморфизм)
    pen.draw()
    pen.change()
    pencil = Pencil('Pencil', 100)
    pencil.draw()
    pencil.sharpen()
    stylus = Stylus('Stylus')
    stylus.draw()
    stylus.charge()
   

"""
Несмотря на то, что у Pen, Pencil and Stylus нет конструктора, мы передаём имя, так как он наследуется от его 
родителя.

Если бы для Pencil и др. не переопределили бы метод draw, он бы воспользовался состоянием Родителя.

Инкапсуляция подразумевает, что если метод приватный, его не стоит вызывать вне нашего класса.
"""

В классах def не функции, а методы!!!!!! Так как у неё появляется self в параметрах.

Классы создаются ещё и для того, чтобы сократить повторяющийся код.

OOП в деталях:
- Класс — тип, описывающий устройство объектов.
- Объект — это экземпляр класса. Класс можно сравнить с чертежом, по которому создаются объекты.
- Наследование - может наследовать данные и функциональность некоторого существующего типа, способствуя 
повторному использованию компонентов
- Инкапсуляция - это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя.
- Полиморфизм - разное поведение одного и того же метода в разных классах

Джедаи:
class Human:
    def __init__(self, name, power):    # таким образом я могу начать описывать мой объект
        self.name = name


    def defend(self):
        print('Глухая защита')

class DefaultHumanPower(Human):
    def __init__(self, name, power, ammo):    # таким образом я могу начать описывать мой объект
        self.name = name
        self._power = power * 3.12342
        self.ammo = []

    def printName(self):    # у функции внутри класса будет обязательный параметр self
        print('Mario')    # это имя будет во всех случаях и наследоваться другими классами

    def add_ammo(self, gun):
        self.ammo.append(gun)

    def attack(self):
        print(self._power)

    def defend(self):
        print('Глухая защита')


class Jedi(DefaultHumanPower):
    def printName(self):
        print(self.name)    # тут мы будем выводить иное имя, а не дефолтное Mario

    def restore(self):    # добавляем особенное свойство для этого класса.
        if self._power > 10:
            print('Restore health')
        else:
            print('Страдать')


class Sith(DefaultHumanPower):
    def printName(self):
        print(self.name)    # тут мы будем выводить иное имя, а не дефолтное Mario

    def kill(self):
        print('Убийство')

    def gram(self):
        print('Захват')



class Separatist(Human):
    def printName(self):
        print(self.name)    # тут мы будем выводить иное имя, а не дефолтное Mario

    def change_thing(self, thing):
        print(thing)


if __name__ == '__main__':
    pen = Pen('Pen')
    pen.draw()
    pen.change()
    pencil = Pencil('Pencil', 100)
    pencil.draw()
    pencil.sharpen()
    stylus = Stylus('Stylus')
    stylus.draw()
    stylus.charge()




