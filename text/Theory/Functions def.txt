
Предположим, надо три раза подряд запрашивать на ввод пару чисел и складывать их. С этой целью можно использовать цикл:
i = 0
while i < 3:
    a = int(input())
    b = int(input())
    print(a+b)
    i += 1

Однако, что если перед каждым запросом чисел, надо выводить надпись, зачем они нужны, и каждый раз эта надпись разная.
Рассмотрим полную версию программы с функцией:

def countFood():
    a = int(input())
    b = int(input())
    print("Всего", a+b, "шт.")

print("Сколько бананов и ананасов для обезьян?")
countFood()

print("Сколько жуков и червей для ежей?")
countFood()

print("Сколько рыб и моллюсков для выдр?")
countFood()


----------------------Передача аргументов функции------------------------------
Вы также можете вызвать функцию, указав наименование аргументов:


print( add(a = 2, b = 3) ) # 5

total = add(b = 4, a = 5)
print(total) # 9
1
2
3
4
print( add(a = 2, b = 3) ) # 5
 
total = add(b = 4, a = 5)
print(total) # 9

--------------------Функции высшего порядка----------------------------------
Функцию, принимающую другую функцию в качестве аргумента и/или возвращающую другую функцию, называют функцией высшего порядка:
def f(x):
    return x + 3

def g(function, x):
    return function(x) * function(x)

print(g(f, 7))
 
-----------------------------------Списковые включения или генератор списка--------------------
Рассмотрим одну конструкцию языка, которая поможет сократить количество строк кода. Не редко уровень программиста на Python можно определить 
с помощью этой конструкции.

Пример кода:
for x in xrange(5, 10):
    if x % 2 == 0:
        x =* 2
    else:
        x += 1

Цикл с условием, подобные встречаются не редко. А теперь попробуем эти 5 строк превратить в одну:
>>> [x * 2 if x % 2 == 0 else x + 1 for x in xrange(5, 10)]
[6, 12, 8, 16, 10]
Недурно, 5 строк или 1. Причем выразительность повысилась и такой код проще понимать - один комментарий можно на всякий случай добавить.

В общем виде эта конструкция такова:
[stmt for var in iterable if predicate] 
Стоит понимать, что если код совсем не читаем, то лучше отказаться от такой конструкции.


Выход из функции и передача данных в то место, откуда она была вызвана, выполняется оператором return. Если интерпретатор Питона, 
 выполняя тело функции, встречает return, то он "забирает" значение, указанное после этой команды, и "уходит" из функции.

Пример:
 def cylinder():
    r = float(input())
    h = float(input())
    # площадь боковой поверхности цилиндра:
    side = 2 * 3.14 * r * h
    # площадь одного основания цилиндра:
    circle = 3.14 * r**2
    # полная площадь цилиндра:
    full = side + 2 * circle
    return full

square = cylinder()
print(square)

Пример выполнения:
3
7
188.4

В основной ветке программы это значение присваивается глобальной переменной square. То есть выражение square = cylinder() выполняется так:
- Вызывается функция cylinder().
- Из нее возвращается значение.
- Это значение присваивается переменной square.

Не обязательно присваивать результат переменной, его можно сразу вывести на экран:
...
print(cylinder())

Если мы в программе просто напишем cylinder(), не присвоив полученные данные переменной или не передав их куда-либо дальше, 
то эти данные будут потеряны.

В функции может быть несколько операторов return. Однако всегда выполняется только один из них. Тот, которого первым достигнет поток выполнения. 
Допустим, мы решили обработать исключение, возникающее на некорректный ввод. Пусть тогда в ветке except обработчика исключений происходит 
выход из функции без всяких вычислений и передачи значения:

def cylinder():
    try:
        r = float(input())
        h = float(input())
    except ValueError:
        return
    side = 2 * 3.14 * r * h
    circle = 3.14 * r**2
    full = side + 2 * circle
    return full

print(cylinder())

Если попытаться вместо цифр ввести буквы, то сработает return, вложенный в except. Он завершит выполнение функции, так что все 
нижеследующие вычисления, в том числе return full, будут опущены. Пример выполнения:
r
None


None- это ничего, такой объект – "ничто". Он принадлежит классу NoneType. До этого мы знали четыре типа данных, они же четыре класса: 
int, float, str, bool. Пришло время пятого.
Когда после return ничего не указывается, то по умолчанию считается, что там стоит объект None. 
Но никто вам не мешает явно написать return None.



------------------------------------Возврат нескольких значений--------------------------------------
В Питоне позволительно возвращать из функции несколько объектов, перечислив их через запятую после команды return:
def cylinder():
    r = float(input())
    h = float(input())
    side = 2 * 3.14 * r * h
    circle = 3.14 * r**2
    full = side + 2 * circle
    return side, full

sCyl, fCyl = cylinder()
print("Площадь боковой поверхности %.2f" % sCyl)
print("Полная площадь %.2f" % fCyl)

Из функции cylinder() возвращаются два значения. Первое из них присваивается переменной sCyl, второе – fCyl. Возможность такого группового 
присвоения – особенность Python, обычно не характерная для других языков:
>>> a, b, c = 10, 15, 19
>>> a
10
>>> b
15
>>> c
19
Фокус здесь в том, что перечисление значений через запятую (например, 10, 15, 19) создает объект типа tuple. На русский переводится как "кортеж". 
Это разновидность структур данных, которые будут изучены позже.
Когда же кортеж присваивается сразу нескольким переменным, то происходит сопоставление его элементов соответствующим в очереди переменным. 
Это называется распаковкой.
Таким образом, когда из функции возвращается несколько значений, на самом деле из нее возвращается один объект класса tuple. 
Перед возвратом эти несколько значений упаковываются в кортеж. Если же после оператора return стоит только одна переменная или объект, 
то ее/его тип сохраняется как есть.
Распаковка не является обязательной. Будет работать и так:
…
print(cylinder())

Пример выполнения:
4
3
(75.36, 175.84)
На экран выводится кортеж, о чем говорят круглые скобки. Его также можно присвоить одной переменной, а потом вывести ее значение на экран.


!!!Функции без инструкции return (равно как и с нею, но без указания аргумента) всё равно возвращают результат — None.!!!!

def do_work(work, reverse=False):
    """Выполняет работу.
    
    В случае удачного выполнения, возвращает True, 
    иначе — False.
    
    :param list work: Список для работы.
    :param bool reverse: Флаг. Следует ли сделать 
        работу в обратном порядке
    :rtype: bool
    """

    В примере выше объявляется функция do_work, с формальными параметрами work и reverse. 
    Функция задокументирована (испольузется формат описания сигнатуры reStructuredText). 
    Кроме строки документации тело функции не содержит инструкций, тем не менее функция возвращает None

    Более того, ничто не мешает использовать «объект функции» как любой другой объект (например: 
    передавать в функцию, использовать в качестве значения в словаре и т.п.).

    def print_yes():
        print('yes')
    def print_no():
        print('no')
    my_functions = [print_yes, print_no]
    for function in my_functions:
        # Переменная function будет содержать объект 
        # функции. Его-то мы и вызываем в следующей строке.
        function()

Cсылаться на глобальные переменные внутри функции можно, а присвоить им значение (без использования инструкции global) 
нельзя.

Когда функция вызывает другую функцию, для вызова создаётся новая локальная символьная таблица:
 def mutate_list(a_list):
        a_list.append(0)
        return True


    my_list = [1]
    print(my_list)  # [1]

    mutate_list(my_list)  # True
    print(my_list)  # [1, 0]

Теория и как связывать
def sum(x, y)
   return x + y (edited) 

   
def sum(*args)
   summa = 0
   for arg in args
       summa = summa + arg
retrun summa (edited) 

def generateMessages(**messages)
   return messages (edited) 

generateMessages(a='test', k='Igor', t=10)

def someFunction()
   ...
   return result

result1 = Func1()
result2 = Func2(result1)
result3 = Func3(result2)